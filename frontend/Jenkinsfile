pipeline {
    agent any
    
    environment {
        NODE_VERSION = '18.x'
        FRONTEND_DIR = 'frontend'
        BUILD_DIR = '${WORKSPACE}/${FRONTEND_DIR}'
        BACKUP_DIR = '${WORKSPACE}/backups'
        SLACK_WEBHOOK_URL = credentials('slack-webhook-url')
        SLACK_CHANNEL = '#team2'
        DEPLOYMENT_URL = 'http://localhost:3000'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
    }
    
    triggers {
        // Auto-trigger on every commit
        pollSCM('H/5 * * * *') // Poll every 5 minutes
        // For GitHub/GitLab webhooks, configure in Jenkins UI:
        // Manage Jenkins > Configure System > GitHub/GitLab webhooks
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "Checking out code from ${env.GIT_BRANCH}"
                    checkout scm
                    // Get commit information
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    env.GIT_COMMIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=%an',
                        returnStdout: true
                    ).trim()
                    env.GIT_COMMIT_HASH = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                }
            }
        }
        
        stage('Create Backup') {
            steps {
                script {
                    echo "Creating backup of previous build..."
                    sh """
                        mkdir -p ${BACKUP_DIR}
                        if [ -d "${BUILD_DIR}/.next" ]; then
                            tar -czf ${BACKUP_DIR}/backup-${BUILD_NUMBER}-${env.GIT_COMMIT_HASH}.tar.gz \
                                -C ${BUILD_DIR} .next package.json package-lock.json
                            echo "Backup created: backup-${BUILD_NUMBER}-${env.GIT_COMMIT_HASH}.tar.gz"
                        fi
                    """
                }
            }
        }
        
        stage('Setup Node.js') {
            steps {
                script {
                    echo "Setting up Node.js ${NODE_VERSION}"
                    // Use NodeJS plugin if available, otherwise install manually
                    try {
                        sh '''
                            if command -v node &> /dev/null; then
                                echo "Node.js already installed: $(node --version)"
                                echo "npm version: $(npm --version)"
                            else
                                echo "Installing Node.js..."
                                curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
                                sudo apt-get install -y nodejs
                            fi
                            node --version
                            npm --version
                        '''
                    } catch (Exception e) {
                        echo "Node.js setup failed: ${e.message}"
                        echo "Ensure Node.js is installed on Jenkins server"
                        throw e
                    }
                }
            }
        }
        
        stage('Install Dependencies') {
            steps {
                dir(FRONTEND_DIR) {
                    script {
                        echo "Installing npm dependencies..."
                        sh 'npm ci'
                    }
                }
            }
        }
        
        stage('Security Audit') {
            steps {
                dir(FRONTEND_DIR) {
                    script {
                        echo "Running security audit..."
                        sh '''
                            node scripts/security-audit.js || true
                            npm audit --audit-level=moderate || true
                        '''
                    }
                }
            }
            post {
                always {
                    script {
                        // Archive security audit results
                        archiveArtifacts artifacts: 'frontend/security-audit-report.json', allowEmptyArchive: true
                        
                        // Check for security issues and send notification
                        checkSecurityIssues()
                    }
                }
            }
        }
        
        stage('Lint') {
            steps {
                dir(FRONTEND_DIR) {
                    script {
                        echo "Running ESLint..."
                        sh 'npm run lint || true'
                    }
                }
            }
        }
        
        stage('Build') {
            steps {
                dir(FRONTEND_DIR) {
                    script {
                        echo "Building Next.js application..."
                        sh '''
                            export NODE_ENV=production
                            npm run build
                        '''
                    }
                }
            }
            post {
                success {
                    script {
                        echo "Build succeeded! Sending notification..."
                        sendSlackNotification('success')
                    }
                }
                failure {
                    script {
                        echo "Build failed! Sending notification..."
                        sendSlackNotification('failure')
                    }
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    echo "Running health check..."
                    dir(FRONTEND_DIR) {
                        sh 'node scripts/health-check.js || true'
                    }
                }
            }
            post {
                always {
                    script {
                        // Archive health check results
                        archiveArtifacts artifacts: 'frontend/health-check-report.json', allowEmptyArchive: true
                        
                        // Check for health issues and send notification
                        checkHealthIssues()
                    }
                }
            }
        }
        
        stage('Performance Test') {
            steps {
                script {
                    echo "Running performance tests..."
                    dir(FRONTEND_DIR) {
                        sh 'node scripts/performance-monitor.js || true'
                    }
                }
            }
            post {
                always {
                    script {
                        // Archive performance reports
                        archiveArtifacts artifacts: 'frontend/performance-report.json', allowEmptyArchive: true
                        
                        // Check for performance issues and send notification
                        checkPerformanceIssues()
                    }
                }
            }
        }
        
        stage('Deploy') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                    branch 'prince'
                }
            }
            steps {
                script {
                    echo "Deploying frontend to localhost:3000..."
                    
                    sh '''
                        cd ${BUILD_DIR}
                        
                        # Install PM2 if not available (recommended for process management)
                        if ! command -v pm2 &> /dev/null; then
                            echo "Installing PM2..."
                            npm install -g pm2
                        fi
                        
                        # Stop existing frontend process if running
                        pm2 stop medilink-frontend || true
                        pm2 delete medilink-frontend || true
                        
                        # Ensure port 3000 is available
                        echo "Checking port 3000..."
                        lsof -ti:3000 | xargs kill -9 2>/dev/null || true
                        
                        # Start frontend on port 3000
                        echo "Starting frontend on port 3000..."
                        PORT=3000 pm2 start npm --name "medilink-frontend" -- start
                        
                        # Save PM2 process list
                        pm2 save
                        
                        # Display PM2 status
                        pm2 status
                        
                        echo "Frontend deployed successfully!"
                        echo "Access frontend at: http://localhost:3000"
                    '''
                }
            }
            post {
                success {
                    script {
                        echo "Deployment successful!"
                        sendSlackNotification('success')
                    }
                }
                failure {
                    script {
                        echo "Deployment failed!"
                        sendSlackNotification('failure')
                    }
                }
            }
        }
        
        stage('Post-Deployment Monitoring') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                    branch 'prince'
                }
            }
            steps {
                script {
                    echo "Starting post-deployment monitoring..."
                    // Wait for deployment to stabilize
                    sleep(time: 30, unit: 'SECONDS')
                    
                    // Run health checks
                    sh '''
                        for i in {1..5}; do
                            echo "Health check attempt $i..."
                            curl -f ${DEPLOYMENT_URL}/api/health || curl -f ${DEPLOYMENT_URL} || true
                            sleep 10
                        done
                    '''
                    
                    // Run performance monitoring
                    dir(FRONTEND_DIR) {
                        sh 'node scripts/performance-monitor.js || true'
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo "Pipeline completed. Generating summary..."
                generateBuildSummary()
            }
        }
        success {
            script {
                echo "Pipeline succeeded!"
                sendSlackNotification('success')
            }
        }
        failure {
            script {
                echo "Pipeline failed!"
                sendSlackNotification('failure')
            }
        }
        cleanup {
            script {
                // Clean up old backups (keep last 10)
                sh """
                    cd ${BACKUP_DIR}
                    ls -t | tail -n +11 | xargs rm -f || true
                """
                // Clean up workspace
                cleanWs()
            }
        }
    }
}

// Helper function to send Slack notifications
def sendSlackNotification(String status) {
    // Check if Slack webhook URL is configured
    def webhookUrl = SLACK_WEBHOOK_URL?.toString()?.trim()
    if (!webhookUrl || webhookUrl.isEmpty()) {
        echo "Slack webhook URL not configured, skipping notification"
        return
    }
    
    def color = status == 'success' ? 'good' : status == 'failure' ? 'danger' : 'warning'
    def emoji = status == 'success' ? 'âœ…' : status == 'failure' ? 'âŒ' : 'âš ï¸'
    
    // Get commit message and handle multiline/empty cases
    def commitMsg = env.GIT_COMMIT_MSG ?: ''
    
    // If commit message is not set, try to get it directly from git
    if (!commitMsg || commitMsg.isEmpty()) {
        try {
            // Ensure we're in the workspace root where git repo is
            dir(env.WORKSPACE ?: '.') {
                commitMsg = sh(
                    script: 'git log -1 --pretty=%B',
                    returnStdout: true
                ).trim()
            }
        } catch (Exception e) {
            echo "Could not retrieve commit message: ${e.message}"
            commitMsg = 'No commit message available'
        }
    }
    
    // Take first line if multiline, truncate if too long (max 200 chars)
    if (commitMsg && !commitMsg.isEmpty()) {
        commitMsg = commitMsg.split('\n')[0].trim()
        if (commitMsg.length() > 200) {
            commitMsg = commitMsg.substring(0, 197) + '...'
        }
    } else {
        commitMsg = 'No commit message'
    }
    
    // Get commit hash with fallback
    def commitHash = env.GIT_COMMIT_HASH ?: 'unknown'
    if (commitHash == 'unknown') {
        try {
            dir(env.WORKSPACE ?: '.') {
                commitHash = sh(
                    script: 'git rev-parse --short HEAD',
                    returnStdout: true
                ).trim()
            }
        } catch (Exception e) {
            echo "Could not retrieve commit hash: ${e.message}"
        }
    }
    
    // Get author with fallback
    def author = env.GIT_COMMIT_AUTHOR ?: 'Unknown'
    if (author == 'Unknown') {
        try {
            dir(env.WORKSPACE ?: '.') {
                author = sh(
                    script: 'git log -1 --pretty=%an',
                    returnStdout: true
                ).trim()
            }
        } catch (Exception e) {
            echo "Could not retrieve commit author: ${e.message}"
        }
    }
    
    // Debug output
    echo "Commit Message: ${commitMsg}"
    echo "Commit Hash: ${commitHash}"
    echo "Author: ${author}"
    
    // Get branch name, clean it up
    def branch = env.GIT_BRANCH ?: 'unknown'
    branch = branch.replaceAll('origin/', '').replaceAll('refs/heads/', '')
    
    // Build message with proper formatting
    def title = "${emoji} Frontend Build ${status.toUpperCase()}"
    def statusMsg = status == 'success' ? 'ðŸŽ‰ Build deployed successfully!' : 'âš ï¸ Build failed. Please check the console logs.'
    
    try {
        // Escape JSON special characters properly
        def escapeJson = { String str ->
            if (!str) return ''
            return str.replace('\\', '\\\\')
                     .replace('"', '\\"')
                     .replace('\n', '\\n')
                     .replace('\r', '\\r')
                     .replace('\t', '\\t')
        }
        
        def escapedCommitMsg = escapeJson(commitMsg)
        def escapedCommitHash = escapeJson(commitHash)
        def escapedAuthor = escapeJson(author)
        def escapedBranch = escapeJson(branch)
        def escapedTitle = escapeJson(title)
        def escapedStatusMsg = escapeJson(statusMsg)
        
        // Build JSON payload with proper escaping
        def jsonPayload = """{
            "channel": "${SLACK_CHANNEL}",
            "username": "Jenkins CI/CD",
            "icon_emoji": ":jenkins:",
            "attachments": [{
                "color": "${color}",
                "title": "${escapedTitle}",
                "fields": [
                    {
                        "title": "Commit",
                        "value": "${escapedCommitHash}",
                        "short": true
                    },
                    {
                        "title": "Author",
                        "value": "${escapedAuthor}",
                        "short": true
                    },
                    {
                        "title": "Branch",
                        "value": "${escapedBranch}",
                        "short": true
                    },
                    {
                        "title": "Build",
                        "value": "#${BUILD_NUMBER}",
                        "short": true
                    },
                    {
                        "title": "Commit Message",
                        "value": "${escapedCommitMsg}",
                        "short": false
                    }
                ],
                "footer": "${escapedStatusMsg}",
                "footer_icon": ":jenkins:",
                "ts": ${System.currentTimeMillis() / 1000}
            }]
        }"""
        
        // Write JSON to file to avoid shell escaping issues
        writeFile file: 'slack-payload.json', text: jsonPayload
        
        sh """
            curl -X POST "${webhookUrl}" \\
            -H 'Content-Type: application/json' \\
            -d @slack-payload.json
        """
        
        echo "Slack notification sent successfully"
    } catch (Exception e) {
        echo "Failed to send Slack notification: ${e.message}"
        // Fallback: try with simple text format
        try {
            def escapedCommitMsg = commitMsg.replace('"', '\\"').replace('\n', ' ')
            def fallbackMsg = "${title}\\n\\n*Commit:* ${commitHash}\\n*Message:* ${escapedCommitMsg}\\n*Author:* ${author}\\n*Branch:* ${branch}\\n*Build:* #${BUILD_NUMBER}\\n\\n${statusMsg}"
            sh """
                curl -X POST "${webhookUrl}" \\
                -H 'Content-Type: application/json' \\
                -d '{"channel": "${SLACK_CHANNEL}", "username": "Jenkins CI/CD", "attachments": [{"color": "${color}", "text": "${fallbackMsg}"}]}'
            """
        } catch (Exception e2) {
            echo "Fallback Slack notification also failed: ${e2.message}"
        }
    }
}

// Helper function to generate build summary
def generateBuildSummary() {
    def summary = """
========================================
Frontend CI/CD Pipeline Summary
========================================
Build Number: ${BUILD_NUMBER}
Status: ${currentBuild.currentResult}
Branch: ${env.GIT_BRANCH}
Commit: ${env.GIT_COMMIT_HASH}
Author: ${env.GIT_COMMIT_AUTHOR}
Commit Message: ${env.GIT_COMMIT_MSG}
Duration: ${currentBuild.durationString}
Build URL: ${env.BUILD_URL}
========================================
""".stripIndent()
    
    echo summary
    
    // Write summary to file
    writeFile file: 'build-summary.txt', text: summary
    archiveArtifacts artifacts: 'build-summary.txt', allowEmptyArchive: true
}

// Helper function to read JSON report file
def readJsonReport(String filePath) {
    try {
        def reportPath = "${FRONTEND_DIR}/${filePath}"
        if (fileExists(reportPath)) {
            def reportContent = readFile(reportPath)
            return new groovy.json.JsonSlurper().parseText(reportContent)
        }
    } catch (Exception e) {
        echo "Warning: Could not read report file ${filePath}: ${e.message}"
    }
    return null
}

// Check for security issues and send notification
def checkSecurityIssues() {
    def report = readJsonReport('security-audit-report.json')
    if (!report) {
        echo "Security audit report not found, skipping notification check"
        return
    }
    
    def hasCriticalIssues = false
    def issues = []
    
    // Check status
    if (report.status == 'critical') {
        hasCriticalIssues = true
    }
    
    // Check for high/critical vulnerabilities
    def criticalVulns = report.vulnerabilities?.findAll { vuln ->
        vuln instanceof Map && (vuln.severity == 'critical' || vuln.severity == 'high')
    } ?: []
    
    if (criticalVulns.size() > 0) {
        hasCriticalIssues = true
        issues.add("Found ${criticalVulns.size()} high/critical vulnerabilities")
        criticalVulns.take(5).each { vuln ->
            def pkg = vuln.package ?: 'unknown'
            def title = vuln.title ?: vuln.message ?: 'No title'
            issues.add("â€¢ ${pkg}: ${title}")
        }
    }
    
    // Check for exposed secrets
    def exposedSecrets = report.dataProtection?.exposedSecrets ?: []
    if (exposedSecrets.size() > 0) {
        hasCriticalIssues = true
        issues.add("Found ${exposedSecrets.size()} potential exposed secrets")
    }
    
    // Check for high severity security issues
    // securityIssues can contain both objects and strings, so we need to handle both
    def highSeverityIssues = report.securityIssues?.findAll { issue ->
        issue instanceof Map && issue.severity == 'high'
    } ?: []
    
    if (highSeverityIssues.size() > 0) {
        hasCriticalIssues = true
        issues.add("Found ${highSeverityIssues.size()} high severity security issues")
    }
    
    // Send notification if critical issues found
    if (hasCriticalIssues) {
        sendIssueNotification('security', report.status, issues, criticalVulns.size() ?: 0)
    } else if (report.status == 'warning') {
        // Send warning for non-critical issues
        def warnings = []
        if (report.vulnerabilities?.size() > 0) {
            warnings.add("Found ${report.vulnerabilities.size()} vulnerabilities (non-critical)")
        }
        if (report.securityIssues?.size() > 0) {
            warnings.add("Found ${report.securityIssues.size()} security issues")
        }
        sendIssueNotification('security', 'warning', warnings, 0)
    }
}

// Check for health issues and send notification
def checkHealthIssues() {
    def report = readJsonReport('health-check-report.json')
    if (!report) {
        echo "Health check report not found, skipping notification check"
        return
    }
    
    def hasIssues = false
    def issues = []
    
    // Check overall status
    if (report.status == 'unhealthy') {
        hasIssues = true
        issues.add("Application health check failed")
    } else if (report.status == 'degraded') {
        hasIssues = true
        issues.add("Application health is degraded")
    }
    
    // Check for errors
    def errors = report.errors ?: []
    if (errors.size() > 0) {
        hasIssues = true
        issues.add("Found ${errors.size()} health check errors")
        errors.take(5).each { error ->
            issues.add("â€¢ ${error}")
        }
    }
    
    // Check for failed checks
    def failedChecks = report.checks?.findAll { check -> check.healthy == false } ?: []
    if (failedChecks.size() > 0) {
        hasIssues = true
        issues.add("${failedChecks.size()} health checks failed")
    }
    
    // Send notification if issues found
    if (hasIssues) {
        sendIssueNotification('health', report.status, issues, errors.size())
    }
}

// Check for performance issues and send notification
def checkPerformanceIssues() {
    def report = readJsonReport('performance-report.json')
    if (!report) {
        echo "Performance report not found, skipping notification check"
        return
    }
    
    def hasCriticalIssues = false
    def issues = []
    
    // Check status
    if (report.status == 'error' || report.status == 'needs_attention') {
        hasCriticalIssues = true
    }
    
    // Check for high priority recommendations
    def highPriorityRecs = report.metrics?.recommendations?.findAll { 
        it.priority == 'high' 
    } ?: []
    
    if (highPriorityRecs.size() > 0) {
        hasCriticalIssues = true
        issues.add("Found ${highPriorityRecs.size()} high priority performance issues")
        highPriorityRecs.each { rec ->
            issues.add("â€¢ ${rec.message}")
        }
    }
    
    // Check bundle size
    def bundleSize = report.metrics?.bundleSize?.totalSize
    if (bundleSize && bundleSize > 10 * 1024 * 1024) { // > 10MB
        hasCriticalIssues = true
        issues.add("Bundle size exceeds threshold: ${(bundleSize / 1024 / 1024).toFixed(2)}MB")
    }
    
    // Check for warnings
    def warnings = report.warnings ?: []
    if (warnings.size() > 5) {
        hasCriticalIssues = true
        issues.add("Found ${warnings.size()} performance warnings")
    }
    
    // Send notification if critical issues found
    if (hasCriticalIssues) {
        sendIssueNotification('performance', report.status, issues, highPriorityRecs.size())
    } else if (report.status == 'warning' && warnings.size() > 0) {
        def warningList = warnings.take(3).collect { "â€¢ ${it}" }
        sendIssueNotification('performance', 'warning', warningList, 0)
    }
}

// Helper function to send detailed issue notifications
def sendIssueNotification(String issueType, String status, List<String> issues, int criticalCount) {
    // Check if Slack webhook URL is configured
    def webhookUrl = SLACK_WEBHOOK_URL?.toString()?.trim()
    if (!webhookUrl || webhookUrl.isEmpty()) {
        echo "Slack webhook URL not configured, skipping ${issueType} notification"
        return
    }
    
    def color = 'warning'
    def emoji = 'âš ï¸'
    def title = ''
    
    switch(issueType) {
        case 'security':
            color = (status == 'critical') ? 'danger' : 'warning'
            emoji = (status == 'critical') ? 'ðŸ”´' : 'ðŸŸ¡'
            title = 'Security Audit Alert'
            break
        case 'health':
            color = (status == 'unhealthy') ? 'danger' : 'warning'
            emoji = (status == 'unhealthy') ? 'âŒ' : 'âš ï¸'
            title = 'Health Check Alert'
            break
        case 'performance':
            color = (status == 'error' || status == 'needs_attention') ? 'warning' : 'good'
            emoji = (status == 'error' || status == 'needs_attention') ? 'âš¡' : 'âœ…'
            title = 'Performance Alert'
            break
    }
    
    def issuesText = issues.size() > 0 ? issues.join('\\n') : 'No specific issues listed'
    
    def message = "${emoji} *${title} - ${status.toUpperCase()}*\\n\\n*Build:* #${BUILD_NUMBER}\\n*Branch:* ${env.GIT_BRANCH}\\n*Commit:* ${env.GIT_COMMIT_HASH}\\n*Author:* ${env.GIT_COMMIT_AUTHOR}\\n\\n*Issues Found:*\\n${issuesText}\\n\\n*Critical Count:* ${criticalCount}\\n\\n*Console:* ${env.BUILD_URL}console\\n*Report:* Check archived artifacts for detailed report"
    
    // Properly escape JSON string
    def escapedMessage = message
        .replace('\\', '\\\\')
        .replace('"', '\\"')
        .replace('\n', '\\n')
        .replace('\r', '')
        .replace('$', '\\$')
    
    try {
        sh """
            curl -X POST "${webhookUrl}" \\
            -H 'Content-Type: application/json' \\
            -d '{
                "channel": "${SLACK_CHANNEL}",
                "username": "Jenkins CI/CD",
                "icon_emoji": ":jenkins:",
                "attachments": [{
                    "color": "${color}",
                    "text": "${escapedMessage}",
                    "mrkdwn_in": ["text"]
                }]
            }'
        """
        echo "Sent ${issueType} notification to Slack"
    } catch (Exception e) {
        echo "Failed to send ${issueType} notification: ${e.message}"
    }
}

